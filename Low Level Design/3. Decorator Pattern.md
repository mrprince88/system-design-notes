The Decorator pattern is a structural design pattern that allows you to dynamically add new behavior to objects. It does so by wrapping them in special objects called decorators, which contain the added behavior. This is an alternative to inheritance.

The Decorator pattern is useful when you want to add behavior to individual objects, rather than to an entire class of objects. It is also useful when you want to add behavior without affecting the existing hierarchy, or when you want to add behavior that can be changed dynamically at runtime.

Points to be noted:
1. Classes should be closed for modification and open for extension.

```ts
interface Component {
    cost(): number;
}

class ConcreteComponent implements Component {
    public cost(): number {
        return 12;
    }
}

class Decorator implements Component {
    protected component: Component;

    constructor(component: Component) {
        this.component = component;
    }

    public cost(): number {
        return this.component.cost();
    }
}

class ConcreteDecoratorA extends Decorator {
    public cost(): number {
        return 10+this.component.cost();
    }
}

class ConcreteDecoratorB extends Decorator {
    public cost(): number {
        return 12+this.component.cost();
    }
}

const simple = new ConcreteComponent();
console.log('I have got a simple component with cost', simple.cost());

const decorator1 = new ConcreteDecoratorA(simple);

console.log(`I have got a simple component decorated with 
            decorator A with cost`,decorator1.cost());

const decorator2 = new ConcreteDecoratorB(decorator1);
console.log(`I have got a simple component decorated with 
            decorator A and B with cost`,decorator2.cost());
```


